//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан для имитации работы Entity Framework.
//     Изменения, вносимые вручную, могут быть перезаписаны при повторном создании.
// </auto-generated>
//------------------------------------------------------------------------------

using RK02.Models;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MovieCatalogApp.Data
{
    /// <summary>
    /// Эмуляция контекста базы данных, аналогичного Entity Framework.
    /// Работает с JSON-файлами, расположенными в папке "Data", вместо реальной базы данных.
    /// Поддерживает добавление, удаление и обновление сущностей с сохранением изменений в файлы.
    /// </summary>
    public partial class FakeDatabase
    {
        private static FakeDatabase _context;
        private readonly string _baseDir;

        /// <summary>
        /// Возвращает единственный экземпляр контекста (реализация паттерна Singleton).
        /// </summary>
        /// <returns>Экземпляр <see cref="FakeDatabase"/>.</returns>
        public static FakeDatabase GetContext()
        {
            return _context ?? (_context = new FakeDatabase());
        }

        /// <summary>
        /// Создает новый экземпляр <see cref="FakeDatabase"/> и загружает данные из JSON-файлов.
        /// </summary>
        /// <param name="dataFolder">Необязательный путь к папке с JSON-файлами. 
        /// Если не указан — используется папка "Data" в корне проекта.</param>
        private FakeDatabase(string dataFolder = null)
        {
            var projectDir = Directory.GetParent(Directory.GetCurrentDirectory()).Parent.Parent.FullName;
            _baseDir = dataFolder ?? Path.Combine(projectDir, "RK02\\Data");
            LoadData();
        }

        public List<Movie> Movies { get; set; }
        public List<Genre> Genres { get; set; }
        public List<User> Users { get; set; }
        public List<Role> Roles { get; set; }

        private readonly List<object> _added = new List<object>();
        private readonly List<object> _removed = new List<object>();
        private readonly List<object> _modified = new List<object>();

        /// <summary>
        /// Загружает данные из JSON-файлов и восстанавливает связи между сущностями.
        /// </summary>
        private void LoadData()
        {
            Movies = LoadFromJson<List<Movie>>(Path.Combine(_baseDir, "movies.json")) ?? new List<Movie>();
            Genres = LoadFromJson<List<Genre>>(Path.Combine(_baseDir, "genres.json")) ?? new List<Genre>();
            Users = LoadFromJson<List<User>>(Path.Combine(_baseDir, "users.json")) ?? new List<User>();
            Roles = LoadFromJson<List<Role>>(Path.Combine(_baseDir, "roles.json")) ?? new List<Role>();

            foreach (var movie in Movies)
                movie.Genre = Genres.FirstOrDefault(g => g.Id == movie.GenreId);

            foreach (var user in Users)
                user.Role = Roles.FirstOrDefault(r => r.Id == user.RoleId);
        }

        /// <summary>
        /// Загружает данные из указанного JSON-файла.
        /// </summary>
        /// <typeparam name="T">Тип данных для десериализации.</typeparam>
        /// <param name="path">Путь к JSON-файлу.</param>
        /// <returns>Объект типа <typeparamref name="T"/> или значение по умолчанию, если файл не найден.</returns>
        private T LoadFromJson<T>(string path)
        {
            if (!File.Exists(path))
                return default;
            var json = File.ReadAllText(path);
            return JsonConvert.DeserializeObject<T>(json);
        }

        /// <summary>
        /// Сохраняет указанные данные в JSON-файл.
        /// </summary>
        /// <typeparam name="T">Тип сохраняемых данных.</typeparam>
        /// <param name="path">Путь к JSON-файлу.</param>
        /// <param name="data">Данные для сохранения.</param>
        private void SaveToJson<T>(string path, T data)
        {
            var json = JsonConvert.SerializeObject(data, Formatting.Indented);
            File.WriteAllText(path, json);
        }

        // ---------- EF-подобные методы ----------
        /// <summary>
        /// Добавляет новую сущность в контекст для последующего сохранения.
        /// </summary>
        /// <typeparam name="T">Тип сущности.</typeparam>
        /// <param name="entity">Добавляемая сущность.</param>
        public void Add<T>(T entity)
        {
            _added.Add(entity);
        }

        /// <summary>
        /// Помечает сущность на удаление из базы (6).
        /// </summary>
        /// <typeparam name="T">Тип сущности.</typeparam>
        /// <param name="entity">Удаляемая сущность.</param>
        public void Remove<T>(T entity)
        {
            _removed.Add(entity);
        }

        public void Update<T>(T entity)
        {
            _modified.Add(entity);
        }

        /// <summary>
        /// Сохраняет все изменения (добавление, удаление, обновление) обратно в JSON-файлы.
        /// </summary>
        /// <remarks>
        /// Метод имитирует поведение <c>DbContext.SaveChanges()</c> из Entity Framework.
        /// </remarks>
        public void SaveChanges()
        {
            // 1️ Добавление
            foreach (var entity in _added)
            {
                if (entity is Movie movie && !Movies.Contains(movie))
                {
                    if (movie.Id == 0)
                        movie.Id = Movies.Any() ? Movies.Max(m => m.Id) + 1 : 1;
                    Movies.Add(movie);
                }
                else if (entity is Genre genre && !Genres.Contains(genre))
                {
                    if (genre.Id == 0)
                        genre.Id = Genres.Any() ? Genres.Max(g => g.Id) + 1 : 1;
                    Genres.Add(genre);
                }
                else if (entity is User user && !Users.Contains(user))
                {
                    if (user.Id == 0)
                        user.Id = Users.Any() ? Users.Max(u => u.Id) + 1 : 1;
                    Users.Add(user);
                }
                else if (entity is Role role && !Roles.Contains(role))
                {
                    if (role.Id == 0)
                        role.Id = Roles.Any() ? Roles.Max(r => r.Id) + 1 : 1;
                    Roles.Add(role);
                }
            }

            // 2️ Удаление
            foreach (var entity in _removed)
            {
                if (entity is Movie movie)
                    Movies.RemoveAll(m => m.Id == movie.Id);
                else if (entity is Genre genre)
                    Genres.RemoveAll(g => g.Id == genre.Id);
                else if (entity is User user)
                    Users.RemoveAll(u => u.Id == user.Id);
                else if (entity is Role role)
                    Roles.RemoveAll(r => r.Id == role.Id);
            }

            // 3️ Модификация 

            // 4️ Сохраняем все списки обратно в JSON
            SaveToJson(Path.Combine(_baseDir, "movies.json"), Movies);
            SaveToJson(Path.Combine(_baseDir, "genres.json"), Genres);
            SaveToJson(Path.Combine(_baseDir, "users.json"), Users);
            SaveToJson(Path.Combine(_baseDir, "roles.json"), Roles);

            // 5️ Очищаем списки отслеживания
            _added.Clear();
            _removed.Clear();
            _modified.Clear();
        }

        /// <summary>
        /// Представляет запись сущности и её текущее состояние.
        /// Используется для имитации работы метода <c>DbContext.Entry()</c> в Entity Framework.
        /// </summary>
        /// <typeparam name="T">Тип сущности.</typeparam>
        public class FakeEntry<T>
        {
            /// <summary>
            /// Сущность, отслеживаемая контекстом.
            /// </summary>
            public T Entity { get; set; }
            /// <summary>
            /// Текущее состояние сущности (Added, Modified, Deleted и т.д.).
            /// </summary>
            public FakeEntityState State { get; set; }
        }

        /// <summary>
        /// Состояние сущности внутри контекста <see cref="FakeDatabase"/>.
        /// </summary>
        public enum FakeEntityState
        {
            /// <summary>Состояние по умолчанию, изменений нет.</summary>
            Unchanged,
            /// <summary>Сущность добавлена и будет вставлена при сохранении.</summary>
            Added,
            /// <summary>Сущность изменена и будет обновлена при сохранении.</summary>
            Modified,
            /// <summary>Сущность удалена и будет исключена при сохранении.</summary>
            Deleted
        }

        /// <summary>
        /// Возвращает объект <see cref="FakeEntry{T}"/> для отслеживания состояния указанной сущности.
        /// </summary>
        /// <typeparam name="T">Тип сущности.</typeparam>
        /// <param name="entity">Экземпляр сущности, состояние которой нужно отслеживать.</param>
        /// <returns>Объект <see cref="FakeEntry{T}"/> с текущим состоянием сущности.</returns>
        public FakeEntry<T> Entry<T>(T entity)
        {
            return new FakeEntry<T> { Entity = entity, State = FakeEntityState.Unchanged };
        }
    }
}